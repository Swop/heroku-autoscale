from ConfigException import ConfigException
import os

class HAConf:
    """Object representation of the config file.
    
    Contains all the parameters of the application.
    Generated by the HAConfigParser.loadConf() (see HAConfigParser.py).
    """
    def __init__(self):
        #Set default value of parameters.
        
        self._heroku = {'api_key': '',
                       'app_name': ''
        }
        self._pingdom = {'api_key': '',
                         'login' : '',
                         'password': '',
                         'check_id': ''
        }
        self._autoscale_settings = {'min_dynos': 1,
                                   'max_dynos': 10,
                                   'response_time_low': 200,
                                   'response_time_high': 2000,
                                   'check_frequency': 5,
                                   'pingdom_check_period': 30,
                                   'response_time_trend_low': -0.5,
                                   'response_time_trend_high': 0.5,
                                   'plot': False,
                                   'graphs_folder': '/tmp',
                                   'debug': False
                                   
        }
    
    def setHerokuAPIKey(self, heroku_api_key):
        """Set the Heroku API Key
        
        Argument:
        - heroku_api_key: The Heroku API Key
        """
        self._heroku['api_key'] = heroku_api_key
        
    def getHerokuAPIKey(self):
        """Get the Heroku API Key
        
        Return: The Heroku API Key
        """
        return self._heroku['api_key']
    
    def setHerokuAppName(self, heroku_app_name):
        """Set the Heroku App name
        
        Argument:
        - heroku_app_name: The Heroku App name
        """
        self._heroku['app_name'] = heroku_app_name
        
    def getHerokuAppName(self):
        """Get the Heroku Application name
        
        Return: The Heroku Application name
        """
        return self._heroku['app_name']
    
    def setPingdomAPIKey(self, pingdom_api_key):
        """Set the Pingdom API Key
        
        Argument:
        - pingdom_api_key: The Pingdom API Key
        """
        self._pingdom['api_key'] = pingdom_api_key
    
    def getPingdomAPIKey(self):
        """Get the Pingdom API Key
        
        Return: The Pingdom API Key
        """
        return self._pingdom['api_key']
    
    def setPingdomLogin(self, pingdom_login):
        """Set the Pingdom login
        
        Argument:
        - pingdom_login: The Pingdom login (email)
        """
        self._pingdom['login'] = pingdom_login
    
    def getPingdomLogin(self):
        """Get the Pingdom login
        
        Return: The Pingdom login
        """
        return self._pingdom['login']
    
    def setPingdomPassword(self, pingdom_password):
        """Set the Pingdom password
        
        Argument:
        - pingdom_password: The Pingdom password
        """
        self._pingdom['password'] = pingdom_password
    
    def getPingdomPassword(self):
        """Get the Pingdom password
        
        Return: The Pingdom password
        """
        return self._pingdom['password']
    
    def setPingdomCheckId(self, pingdom_check_id):
        """Set the Pingdom check ID
        
        Argument:
        - pingdom_check_id: The Pingdom check ID
        """
        self._pingdom['check_id'] = pingdom_check_id
    
    def getPingdomCheckId(self):
        """Get the Pingdom check ID
        
        Return: The Pingdom check ID
        """
        return self._pingdom['check_id']
    
    def setMinDynos(self, min_dynos):
        """Set the minimun number of dynos
        
        The autoscale app will not scale down the Heroku app under that number of dynos
        
        Argument:
        - min_dynos: The minimun number of dynos
        """
        if(min_dynos < 1):
            raise ConfigException("You have to set at least 1 dyno minimum (you indicate {0})".format(min_dynos))
        self._autoscale_settings['min_dynos'] = min_dynos
    
    def getMinDynos(self):
        """Get the minimun number of dynos
        
        The autoscale app will not scale down the Heroku app under that number of dynos
        
        Return: The minimun number of dynos
        """
        return self._autoscale_settings['min_dynos']
    
    def setMaxDynos(self, max_dynos):
        """Set the maximum number of dynos
        
        The autoscale app will not scale up the Heroku app over that number of dynos
        
        Argument:
        - max_dynos: The maximum number of dynos
        """
        self._autoscale_settings['max_dynos'] = max_dynos
        
    def getMaxDynos(self):
        """Get the maximum number of dynos
        
        The autoscale app will not scale up the Heroku app over that number of dynos
        
        Return: The maximum number of dynos
        """
        return self._autoscale_settings['max_dynos']
    
    def setResponseTimeLow(self, response_time_low):
        """Set the response time Low Score
        
        If the measured response time score is below this number, the Heroku app will be scaled up.
        
        Argument:
        - response_time_low: The response time Low Score
        """
        if(response_time_low >= 0):
            self._autoscale_settings['response_time_low'] = response_time_low
        else:
            raise ConfigException("Response time low score must be a int value, over than 0 (you indicate {0})".format(response_time_low))
    
    def getResponseTimeLow(self):
        """Get the response time Low Score
        
        If the measured response time score is below this number, the Heroku app will be scaled up.
        
        Return: The response time Low Score
        """
        return self._autoscale_settings['response_time_low']
        
    def setResponseTimeHigh(self, response_time_high):
        """Set the response time High Score
        
        If the measured response time score is over this number, the Heroku app will be scaled down.
        
        Argument:
        - response_time_high: The response time High Score
        """
        if(response_time_high >= 0):
            self._autoscale_settings['response_time_high'] = response_time_high
        else:
            raise ConfigException("Response time high score must be a int value, over than 0 (you indicate {0})".format(response_time_high))
    
    def getResponseTimeHigh(self):
        """Get the response time High Score
        
        If the measured response time score is over this number, the Heroku app will be scaled down.
        
        Return: The response time high Score
        """
        return self._autoscale_settings['response_time_high']
    
    def setCheckFrequency(self, check_frequency):
        """Set the check frequency (in minutes)
        
        Argument:
        - check_frequency: The check frequency
        """
        if(check_frequency < 1):
            raise ConfigException("The check frequency must be at least 1 minute (you indicate {0})".format(check_frequency))
        self._autoscale_settings['check_frequency'] = check_frequency
        
    def getCheckFrequency(self):
        """Get the check frequency (in minutes)
        
        Return: The check frequency
        """
        return self._autoscale_settings['check_frequency']
    
    def setPingdomCheckPeriod(self, pingdom_check_period):
        """Set the Pingdom check period (in minutes)
        
        Argument:
        - pingdom_check_period: The check period
        """
        if(pingdom_check_period < 1):
            raise ConfigException("The check period must be at least 1 minute (you indicate {0})".format(pingdom_check_period))
        self._autoscale_settings['pingdom_check_period'] = pingdom_check_period
        
    def getPingdomCheckPeriod(self):
        """Get the Pingdom check period (in minutes)
        
        Return: The check period
        """
        return self._autoscale_settings['pingdom_check_period']
    
    def setResponseTimeTrendLow(self, response_time_trend_low):
        """Set the response time trend Low Score
        
        If the measured response time trend score is below this number, the Heroku app will be scaled up.
        
        Argument:
        - response_time_low: The response time trend Low Score
        """
        if(isinstance(response_time_trend_low, float) and response_time_trend_low <= 0):
            self._autoscale_settings['response_time_trend_low'] = response_time_trend_low
        else:
            raise ConfigException("Response time low trend score must be a negative float value (you indicate {0})".format(response_time_trend_low))
    
    def getResponseTimeTrendLow(self):
        """Get the response time trend Low Score
        
        If the measured response time trend score is below this number, the Heroku app will be scaled up.
        
        Return: The response time trend Low Score
        """
        return self._autoscale_settings['response_time_trend_low']
        
    def setResponseTimeTrendHigh(self, response_time_trend_high):
        """Set the response time trend High Score
        
        If the measured response time trend score is over this number, the Heroku app will be scaled down.
        
        Argument:
        - response_time_high: The response time trend High Score
        """
        if(isinstance(response_time_trend_high, float) and response_time_trend_high >= 0):
            self._autoscale_settings['response_time_trend_high'] = response_time_trend_high
        else:
            raise ConfigException("Response time high trend score must be a positive float value (you indicate {0})".format(response_time_trend_high))
    
    def getResponseTimeTrendHigh(self):
        """Get the response time trend High Score
        
        If the measured response time trend score is over this number, the Heroku app will be scaled down.
        
        Return: The response time trend high Score
        """
        return self._autoscale_settings['response_time_trend_high']
    
    def setPlotting(self, plotting):
        """Enable graphs plotting
        
        If enabled, each autoscale step will plot a graph with the response times, the average response time, the response time bounds and the linear regression model of the scatter graph
        
        Argument:
        - plotting: True/False : enable or disable graphs plotting
        """
        if(isinstance(plotting, bool)):
            self._autoscale_settings['plot'] = plotting
        else:
            raise ConfigException("'Plot' value must be boolean (you indicate {0})".format(plotting))
        
    def isPlotting(self):
        """Inform if the graphs plotting is enabled
        
        Return: True/False depending if the graphs plotting is enabled or not
        """
        return  self._autoscale_settings['plot']
    
    def setGraphsFolder(self, graphs_folder):
        """Set the destination folder for the plotted graphs
        
        Argument:
        - graphs_folder: The destination of the plotted graphs
        """
        graphs_folder = os.path.realpath(str(graphs_folder))
        if os.access(graphs_folder, os.F_OK) and (not \
                os.access(graphs_folder, os.R_OK) or not \
                os.access(graphs_folder, os.W_OK)):
            raise ConfigException("Can't read/write in the given directory: {0}".format(graphs_folder))
        elif not os.access(graphs_folder, os.F_OK):
            raise ConfigException("The given directory doesn't exists: {0}".format(graphs_folder))
        
        self._autoscale_settings['graphs_folder'] = graphs_folder
        
    def getGraphsFolder(self):
        """Get the destination folder for the plotted graphs
        
        Return: The destination folder for the plotted graphs
        """
        return  self._autoscale_settings['graphs_folder']
    
    def setDebugMode(self, debug):
        """Place/take off the application in/from debug mode
        
        The Heroku app will not be scale but the scaling decisions will be made and logged (and eventually the graphs will be plotted).
        
        Argument:
        - debug: True/False: Enabled/Disabled the debug mode
        """
        if(isinstance(debug, bool)):
            self._autoscale_settings['debug'] = debug
        else:
            raise ConfigException("'debug' value must be boolean (you indicate {0})".format(debug))
        
    def isInDebugMode(self):
        """Inform if the application is in debug mode or not
        
        Return: True/False depending if the application is in debug mode or not 
        """
        return  self._autoscale_settings['debug']